- 在js编译原理中可以看到，js编译原理分为三部分：第一部分是词法分析，第二部分是语法分析，第三部分是代码生成。
- 在第一部分词法分析的过程中定义的作用域就是词法作用域。
- 词法作用域是由作者在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变。

现在给出一段代码
```
        function foo(a) {
            let b = a * 2;

            function bar(c) {
                console.log(a, b, c);
            }

            bar(b * 3);
        }

        foo(2);
```
- 上面的代码包括三个作用域：
- 首先是全局作用域，它包含有一个标识符`foo`，其值是一个指向堆内存中函数的指针。
- 再然后是foo函数的局部作用域，它包括标识符`b`,标识符`bar`。
- 再然后是bar函数的局部作用域，它包括标识符`c`。

词法作用域决定于代码作者将作用域块代码写在哪里。它们逐级包含。

## 查找
- 词法作用域的标识符查找方式是逐层向上查找。
- 作用域会在找到第一个匹配的标识符时停止。也因此在多层的嵌套作用域中可以定义同名的标识符，这叫做遮蔽效应。
- 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。


## 欺骗词法
### eval
`eval`将其中的内容伪装成好像是代码作者将代码写到那个位置的一样。通过伪装，将原本的词法作用域进行了修改。（原则上词法作用域只有人类才能修改）
- 给出下面一段代码：
```
        function foo(str, a) {
            eval(str); // 欺骗语法
            console.log(a, b);
        }

        var b = 2;
        foo('var b=3;', 1); // 1, 3
```
- 按照词法作用域逐层查找原则，在函数`foo`中的词法作用域是不存在`b`标识符的，也因此需要逐层查找到全局作用域才能找到。
- 但由于`eval`的欺骗，修改了`foo`的词法作用域。在作用域中创造了`b`标识符，遮蔽了外部作用域的同名标识符。
- 如果`eval`接收的字符串中包含有变量声明，就会对`eval`所处的词法作用域进行修改。
- 在严格模式中。`eval`有自己的词法作用域，无法修改所在的作用域。(严格模式下甚至不会允许向上查找)
```
        function foo(str) {
            'use strict';
            eval(str);
            console.log(a);
        }

        foo('var a=2'); // ReferenceError: a is not defined
```

### with
```
        function foo(obj) {
            with(obj) {
                a = 2;
            }
        }
        let obj1 = {
            a: 3
        };
        let obj2 = {
            b: 3
        };
        foo(obj1);
        console.log(obj1.a); // 2

        foo(obj2);
        console.log(obj2.a); // undefined
        console.log(a); // 2
```
- `with`将一个对象处理为一个完全隔离的词法作用域。这个对象的属性也就是定义在这个作用域中的标识符。
- 但是根据上面对于对象内部未声明的变量，`with`语句将变量声明到全局作用域中。原因是：尽管`with`语句可以将一个对象处理为词法作用域，但是这个块内部正常的var声明只会被添加到with所处的函数作用域中。即，当进行LHS标识符查找时，会直接进入`with`所在的外部作用域中查找，而不是在`with`构造的词法作用域中查找。因为函数作用域中也没能找到，所以最后在全局作用域中创建了变量a。

## 性能
- 如果词法分析阶段发现了`eval`或者`with`，那么引擎只能假设关于标识符位置的判定都是无效的。也因此js引擎在这一阶段对于性能的优化都是无效的。（因为js引擎绝大部分功用都花在了对性能的优化上）。也因此不建议使用它们。