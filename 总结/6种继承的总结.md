## 原型链继承

- 解决的是通过一个构造函数访问到另一个构造函数原型对象的方法
- 它没有办法解决引用值属性会被篡改的问题

## 盗用构造函数

- 将父类构造函数通过call和apply在子类中调用
- 它通过让子类保存父类构造函数的引用值副本，成功解决了引用值属性被篡改的问题
- 所有的方法都必须在子类实例中新建，面临和构造函数一样的问题：浪费内存

## 组合继承

- 针对盗用构造函数中，SubType的实例对象与SuperType的原型对象没有联系，导致所有的方法都必须在实例中重新声明的问题。
- 组合继承添加了：1.所有的方法都被赋值给SuperType的原型对象以避免重复创建。2.SuperType的实例赋值给SubType的prototype属性，完成作用域链的继承。
- 它成功地实现了：1.在实例上创建引用值副本避免被篡改的风险。2.在超类构造函数的原型对象中写入函数达到函数的复用效果，避免重复创建实例函数的内存浪费。

## 原型式继承

- 就是创建一个新的对象，然后将新对象的原型对象绑定为另一个对象。正是一个浅复制，新创建的这个对象什么属性都没有却可以使用原型对象的属性。
- ES5中使用Object.create()将其规范化了。

## 寄生式继承

- 原型式继承的基础上，在函数内部添加了为这个新对象添加函数或者其它实例属性的操作。
- 没什么用。和构造函数一样面临实例对象的方法无法复用的境地。

## 寄生式组合继承

- 使用寄生式继承，浅复制SuperType.prototype原型对象并赋值给SubType的原型对象，避免对SuperType构造函数的二次调用（即在组合继承中的两次调用）
- 寄生式组合继承主要解决的组合继承的效率问题：即在组合继承中存在的对超类构造函数的二次调用（子类原型对象赋值一次，子类实例对象创建一次）。通过寄生式继承的方法加长原型链避免对超类构造函数的直接调用。
- 保证了实例对象拥有引用值属性副本和函数的复用的前提下，同时解决了组合继承的两次调用超类构造函数的效率问题。
- 寄生式组合继承是引用类型继承的最佳模式。